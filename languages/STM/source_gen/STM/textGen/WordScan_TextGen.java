package STM.textGen;

/*Generated by MPS */

import jetbrains.mps.textGen.SNodeTextGen;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IVisitor;

public class WordScan_TextGen extends SNodeTextGen {
  public void doGenerateText(SNode node) {
    if (SPropertyOperations.hasValue(node, "parallel", "parallel", "sequential")) {
      this.append("\n @Grab(group='org.codehaus.gpars', module='gpars', version='0.11')");
      this.append("\n import static groovyx.gpars.GParsPool.withPool ");
    }
    this.append("\n def urls = [ ");
    ListSequence.fromList(SLinkOperations.getTargets(node, "urls", true)).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        WordScan_TextGen.this.append("\n \"http://");
        WordScan_TextGen.this.append(SPropertyOperations.getString(it, "value"));
        WordScan_TextGen.this.append("\",");
      }
    });
    this.append("\n ] ");
    if (SPropertyOperations.hasValue(node, "parallel", "parallel", "sequential")) {
      this.append("\n withPool {");
      this.append("\n println 'Found at: ' + urls.findAllParallel{println \"Downloading ${it}\";def result = it.toURL().text.contains('");
      this.append(SPropertyOperations.getString(node, "word"));
      this.append("');println \"Done with ${it}\";result}");
      this.append("\n }");
    } else {
      this.append("\n println 'Found at: ' + urls.findAll{println \"Downloading ${it}\";def result=it.toURL().text.contains('");
      this.append(SPropertyOperations.getString(node, "word"));
      this.append("');println \"Done with ${it}\";result}");
    }
  }
}
